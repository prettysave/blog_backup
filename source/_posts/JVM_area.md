---
title: JVM - JVM内存区域
date: 2020-08-15 13:47:19
categories: JAVA
tags:
- JVM
---



## 线程共享内存：

### 堆内存

堆内存是JVM中最大的一块区域。

1.主要用于存放对象和数组；

2.所有线程共享；

3.堆内存又分为新生代（YoungGeneration）和老年代（OldGeneration）新生代还可以分为Eden、From Survivor、To Survivor。

<!--more-->

### 方法区

在JDK1.8之前,方法区也可以理解为堆的一个“逻辑部分”（一片连续的堆空间）。

1.存储内容：

​	① 类信息

​    ② 常量池

​    ③ 静态变量

 	④ 编译代码

2.在最常用的HotSpot（sun JDK和OpenJDK）虚拟机中，曾一度使用”永久代“的方式实现方法区，但是在jdk1.7开始准备“去永久代”的规划，已经把原本放在永久代中的静态变量、字符串常量池等移到堆内存中，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；在jdk1.8中，永久代已经不存在，原永久代中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。

3.去永久代的原因
（1）字符串存在永久代中，容易出现性能问题和内存溢出。程序在运行过程中往往会产生大量的字符串，而字符串位于永久代，回收困难。  

（2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 

 （3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

**tips**:官方声明中表示因为要JRockit合并，而JRockit没有采用永久代来实现方法区，所以就剔除了HotSpot的永久代实现。（这么说好像也没毛病）

### 元空间

上面说到，jdk1.8中，已经不存在永久代，替代它的一块空间叫做“元空间”，和永久代类似，都是HotSpot对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来指定元空间的大小。

## 线程隔离内存：

### 栈内存

栈内存又分本地方法栈(native method stack)和虚拟机栈(vm stack)，虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在HotSpot中直接把本地方法栈和虚拟机栈合二为一。

1.每个线程都有一个栈，每个栈里面都有N个栈帧，一个栈帧对应一个方法。JAVA中一个方法被调用到执行结束，就是一个栈帧从入栈到出栈的过程。

2.栈帧中存放着局部变量表，操作数栈，动态链接，返回地址等。

**Tips**:每个线程栈的内存并不是分配的越多越好，如果单个栈的内存太多，在线程多的时候就会因为总的栈的内存不够而OOM，所以有时候把单个栈的内存调小也可以达到优化的效果



### 程序计数器

程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间，此外，**程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域**。





