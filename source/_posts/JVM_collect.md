---
title: JVM - 垃圾回收
date: 2020-08-22 17:03:24
categories: JAVA
tags:
- JVM
---



## 如何判断对象可以回收

### 1.引用计数法

给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；每当有一个地方不再引用它时，计数器值减1，这样只要计数器的值不为0，就说明还有地方引用它，它就不是无用的对象。

**不足:**

**当两个对象互相调用的时候，它们的引用计数都是1，都无法回收；**

<!--more-->

### 2.可达性分析算法

当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就说明此对象是不可用的，是死对象。

**GC ROOTS:**

(1) 虚拟机栈中本地变量表中引用的对象

(2) 方法区中静态属性引用的对象

(3) 方法区中常量引用的对象

(4) 本地方法栈中JNI（Native方法）引用的对象

### 3.方法区回收

方法区中主要回收的是废弃的常量和无用的类。 

（1）判断常量是否废弃可以判断是否有地方引用这个常量，如果没有引用则为废弃的常量。 

（2） 判断类是否废弃需要同时满足如下条件：

- 该类所有的实例已经被回收（堆中不存在任何该类的实例）
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象在任何地方没有被引用（无法通过反射访问该类的方法）

## 垃圾回收算法

（1）标记-清除算法：分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图。

缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。（只有CMS垃圾收集器使用，因为这个致命缺陷，在JDK14已经被移除） 

（2）复制算法：把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环。新生代中基本上都是使用的这个算法。

缺点：实际可使用的内存空间缩小为原来的一半，比较适合对象生存周期短的区域。

（3）标记-整理算法：先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存。

## 垃圾收集器

新生代收集器：Serial、ParNew、Parallel Scavenge

老年代收集器：Serial Old、CMS、Parallel Old

堆内存垃圾收集器：G1 

”新“垃圾收集器：ZGC(jdk11 )、Shenandoah（只有OpenJdk才有 从12开始出现）

### （1）Serial 收集器

​		Serial是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。

**适用场景**：Client模式（桌面应用）；单核服务器。可以用-XX:+UserSerialGC来选择Serial作为新生代收集器。

### （2）ParNew 收集器

​		ParNew是一个Serial的多线程版本，其它与Serial并无区别。ParNew在单核CPU环境并不会比Serial收集器达到更好的效果，它默认开启的收集线程数和CPU数量一致，可以通过-XX:ParallelGCThreads来设置垃圾收集的线程数。 

**适用场景**：多核服务器；与CMS收集器搭配使用。当使用-XX:+UserConcMarkSweepGC来选择CMS作为老年代收集器时，新生代收集器默认就是ParNew，也可以用-XX:+UseParNewGC来指定使用ParNew作为新生代收集器。

### （3）Parallel Scavenge 收集器

​		Parallel Scavenge是一款用于新生代的多线程收集器，与ParNew的不同之处是，ParNew的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge的目标是达到一个可控制的吞吐量。

​		可以通过-XX:MaxGCPauseMillis来设置收集器尽可能在多长时间内完成内存回收，可以通过-XX:GCTimeRatio来精确控制吞吐量。

**适用场景**：注重吞吐量，高效利用CPU，需要高效运算且不需要太多交互。可以使用-XX:+UseParallelGC来选择Parallel Scavenge作为新生代收集器，jdk7、jdk8默认使用Parallel Scavenge作为新生代收集器。

### （4）Serial Old收集器

​		Serial Old收集器是Serial的老年代版本，同样是一个单线程收集器，采用标记-整理算法。

**适用场景**：Client模式（桌面应用）；单核服务器；与Parallel Scavenge收集器搭配；作为CMS收集器的后备预案。

### （5）CMS(Concurrent Mark Sweep) 收集器(JDK9中标记废弃，14中移除)

​		CMS收集器是一种以最短回收停顿时间为目标的收集器，以“最短用户线程停顿时间”著称。整个垃圾收集过程分为4个步骤：

 ① 初始标记：标记一下GC Roots能直接关联到的对象，速度较快

 ② 并发标记：进行GC Roots Tracing，标记出全部的垃圾对象，耗时较长 

 ③ 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短  

④ 并发清除：用标记-清除算法清除垃圾对象，耗时较长

**Tips**:整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS收集器垃圾收集可以看做是和用户线程并发执行的。 

CMS收集器也存在一些缺点：

- 对CPU资源敏感：默认分配的垃圾收集线程数为（CPU数+3）/4，随着CPU数量下降，占用CPU资源越多，吞吐量越小
- 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当CMS运行时，预留的内存空间无法满足用户线程的需要，就会出现“Concurrent Mode Failure”的错误，这时将会启动后备预案，临时用Serial Old来重新进行老年代的垃圾收集。
- 因为CMS是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过-XX:UserCMSCompactAtFullCollection开启碎片整理（默认开启），在CMS进行Full GC之前，会进行内存碎片的整理。还可以用-XX:CMSFullGCsBeforeCompaction设置执行多少次不压缩（不进行碎片整理）的Full GC之后，跟着来一次带压缩（碎片整理）的Full GC。  适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用-XX:+UserConMarkSweepGC来选择CMS作为老年代收集器。

### （6）Parallel Old 收集器

​		Parallel Old收集器是Parallel Scavenge的老年代版本，是一个多线程收集器，采用标记-整理算法。可以与Parallel Scavenge收集器搭配，可以充分利用多核CPU的计算能力。

 **适用场景**：与Parallel Scavenge收集器搭配使用；注重吞吐量。jdk7、jdk8默认使用该收集器作为老年代收集器，使用 -XX:+UseParallelOldGC来指定使用Paralle Old收集器。
