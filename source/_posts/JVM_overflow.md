---
title: JVM - 内存溢出
date: 2020-09-05 16:33:45
categories: JAVA
tags:
- JVM
---



## 	JVM内存溢出种类

### 1.堆内存溢出

堆内存中主要存放对象、数组等，只要不断地创建这些对象，并且保证GC Roots到对象之间有可达路径来避免垃圾收集回收机制清除这些对象，当这些对象所占空间超过最大堆容量时，就会产生OutOfMemoryError的异常。

新产生的对象最初分配在新生代，新生代满后会进行一次Minor GC，如果Minor GC后空间不足会把该对象和新生代满足条件的对象放入老年代，老年代空间不足时会进行Full GC，之后如果空间还不足以存放新对象则抛出OutOfMemoryError异常。
<!--more-->


**常见原因**：

**1.内存中加载的数据过多如一次从数据库中取出过多数据**；

**2.集合对对象引用过多且使用完后没有清空**；

**3.代码中存在死循环或循环产生过多重复对象**；

**4.堆内存分配不合理；**

**5.网络连接问题、数据库问题等**。


### 2.栈内存溢出（虚拟机栈/本地方法栈）

- **StackOverflowError**：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常。最常见的场景就是方法无限递归调用

**tips:当出现StackOverflowError的时候说明虚拟机分配的栈的深度不够，可以通过增加栈的深度或者把方法嵌套的层数减少的方式优化**。

- **OutOfMemoryError**：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。我们可以这样理解，虚拟机中可以供栈占用的空间≈可用物理内存 - 最大堆内存 - 最大方法区内存，比如一台机器内存为4G，系统和其他应用占用2G，虚拟机可用的物理内存为2G，最大堆内存为1G，最大方法区内存为512M，那可供栈占有的内存大约就是512M，假如我们设置每个线程栈的大小为1M，那虚拟机中最多可以创建512个线程，超过512个线程再创建就没有空间可以给栈了，就报OutOfMemoryError异常了。

**总结**：

1.在线程较少的时候，某个线程请求深度过大，会报StackOverflow异常，解决这种问题可以适当加大栈的深度（增加栈空间大小），也就是把-Xss的值设置大一些，但一般情况下是代码问题的可能性较大；

2.在虚拟机产生线程时，无法为该线程申请栈空间了，会报OutOfMemoryError异常，解决这种问题可以适当减小栈的深度，也就是把-Xss的值设置小一些，每个线程占用的空间小了，总空间一定就能容纳更多的线程，但是操作系统对一个进程的线程数有限制，经验值在3000~5000左右。在jdk1.5之前-Xss默认是256k，jdk1.5之后默认是1M，这个选项对系统硬性还是蛮大的，设置时要根据实际情况，谨慎操作。

### 3.方法区溢出

前面说到，方法区主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据，所以方法区溢出的原因就是没有足够的内存来存放这些数据。

 由于在jdk1.6之前字符串常量池是存在于方法区中的，所以jdk1.6之前的虚拟机，不断产生不一致的字符串（同时GC Roots有可达路径）会产生方法区的OutOfMemoryError异常；方法区还存储加载的类信息，所以jdk1.7的虚拟机，不断创建大量的类也会导致方法区溢出。

### 4.本地直接内存溢出

本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但Java中用到NIO相关操作时（比如ByteBuffer的allocteDirect方法申请的是本机直接内存），也可能会出现内存溢出的异常。



