---
title: 设计模式（1）- 创建型模式
date: 2019-10-26 13:28:56
categories: 设计模式
tags:
- 创建型模式
---

## 创建型模式

### 简单工厂模式

一个工厂类XxxFactory,里面有一个静态方法，根据不同的传入参数，返回不同的派生自同一个类（接口）的实例对象。

**tips**:强调职责单一原则，一个类只提供一个功能，例如FoodFactory的功能就是只负责生产food,可以根据参数如‘’noodle","chicken"更生成不同的实例对象。
<!--more-->

### 工厂模式

不同于简单工厂模式，工厂模式不仅一个工厂能生成多种Food,并且会有多个工厂，多个工厂都派生自顶层的抽象类（接口）Factory。例如ChineseFactory和AmericanFactory

不同的工厂的生产方法是一样的，**客户端在调用的时候选择好需要的工厂**，工厂就会根据传递的参数返回不同的实例对象。 

![factory-1](https://user-gold-cdn.xitu.io/2018/10/19/1668ac9a05f8e190?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 抽象工厂模式

当涉及到**产品族**的概念时，就要引入抽象工厂模式了。

例如在生产电脑的时候，CPU我们需要一个Factory,此时就会有AMDCPUFactory和IntelCPUFactory。主板我们需要一个Factory,此时也会分别有AMDMainBoardFactory和IntelMainFactoryFactory。当我们需要硬盘、内存条、电源。。。等，这样会产生大量的工厂，当然，这样的好处是解耦了。

但是因为现实中因为Intel和AMD的CPU和主板会出现不兼容的情况，所以如果把所有的工厂都交给客户端调用的话可能就会出现错误的情况。这个时候我们可以选择把“造电脑”抽象出来，抽象一个“ComputerFactory",然后派生出AMDComputerFactory和IntelComputerFactory.将生产CPU、主板、硬盘等方法都放到里面。客户端在调用的时候先选择好需要的ComputerFactory，这也生产的零件就不会有冲突的情况了。客户端也可以灵活的选择组装电脑的零件，例如有的需要两个硬盘，有的不需要显卡等等。

抽象工厂有个明显的缺点就是工厂的功能比较耦合，违背了**职责单一**原则。当ComputerFactory需要增加一个例如生产显示器的功能的时候，需要修改其所有的派生工厂，违背了**对修改关闭，对扩展开放**的原则。

**tips**:设计模式是死的，人是活的，有时候因为业务的強限制，适当破坏原则也是可以的。

![img](https://user-gold-cdn.xitu.io/2018/10/19/1668ac9a0665ea60?imageslim)

### 单例模式

单例模式即返回的对面全局唯一，仅此一份。例如Spring中的bean默认就是单例的。

#### 饿汉模式：

定义一个静态的私有实例，意味着类在第一次使用的时候就会创建这个对面实例。

**tips**:饿汉模式的缺点就是存在在并不需要的时候就会创建这个对象。这个时候就要注意看这个类是否有必要存在其他的和生产对象无关的方法。

#### 饱汉模式：

饱汉模式的思路就是在调用getInstance的时候判断实例对象是否生成，如果已存在则返回，不存在则不返回。

**tips**:

1、构造方法需要private

2、双重检查instance

3、第二次检查前synchronized，如果直接在getInstance方法签名上加synchronized，每次调用的时候都会上锁，这对效率影响很大。如果第二次检查前才syn的话则只有在第一次创建的时候才会上锁，其他时候获取单例对象的时候都不需要上锁。

此外饱汉模式还有一个嵌套类（或者说是静态内部类的实现方式），大意是将单例对象放在嵌套类里（嵌套类里的instance就像饿汉模式那样直接定义对象并实例化），getInstance的时候调用这个嵌套类，这样也实现了在需要实例的时候才生产。

### 建造者模式

平时碰见的XxxBuilder类，通常都是建造者模式的产物。一般都是先new一个Builder,然后链式的调用一堆方法，最后再调用一次build()方法，我们需要的对象就产生了。

例如当我们需要一个目标对象为User的时候，要定义一个UserBuilder的方法。User有的属性UserBuider都有，UserBuilder的set属性的方法的返回值都是this,这样后续可以接着链式的set其他的属性，在build()方法中new一个User并把之前设置好的属性值”复制“过去，这里也可以做一些校验，或者是默认值赋值的操作。

**tips**:User的构造方法得是private，可以在User类中定义一个builder()方法，用来new UserBuilder(),这样客户端在调用的时候看起来比较友好。

建造者模式虽然让人感觉写了很多”无用“的代码，但是当目标类的属性很多，并且有的必需，有的不必需时，在build()中校验比在目标类的构造方法中校验要优雅一点，这样在目标类的构造方法中只需要赋值就可以了，校验放在了实例化之前即build()里先校验在new 目标类()。客户端在调用过程中的赋值操作也清晰明了。

### 原型模式

原型模式很简单：有一个原型**实例**，基于这个原型实例产生新的实例，也就是“克隆”了。

Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先**实现 Cloneable 接口**，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。

**tips**:java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。

### 创建型模式总结

创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是**面向对象**的代码，所以我们第一步当然是需要创建一个对象了。

简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。





参考链接：https://juejin.im/post/5bc96afff265da0aa94a4493
