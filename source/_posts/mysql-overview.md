---
title: mysql概览
date: 2020-09-28 18:41:37
categories: 数据库
tags: mysql
---

## 架构
### 	连接层（服务层）
​		JDBC、ODBC等;
​		连接处理、授权认证等;
### 	服务层（核心服务层）： 
​    	触发器、存储过程、视图等跨存储引擎的功能
​		查询缓存：如果命中缓存 则直接返回结果
​		分析器：词法分析、语法分析
​		优化器：执行计划生成、索引选择
​		执行器：操作引擎，返回结果
### 	存储引擎层
​		负责数据的存储和提取
​		通过API与存储引擎通信
### 存储层 
​		将数据存储于设备的文件系统中，持久化
​		完成与存储引擎的交互
### sql语句执行流程
​		客户端请求→连接器（验证用户身份。给予权限）→
​		查询缓存（存在直接返回，不存在继续后续操作）→
​		分析器（对SQL进行词法、语法分析）→
​		优化器（主要对执行的SQL选择最优的执行方案）→
​		执行器（先验证是否有执行权限，有权限才使用引擎提供的接口）→
​		引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）
## 存储引擎
### 	InnoDB
​		支持事务
​		支持外键
​		最小粒度是行锁
​		自增主键的最大ID记录在内存中
### 	MyISAM
​		不支持事务
​		不支持外键
​		最小粒度是表锁
​		自增主键的最大ID记录在数据文件中 
## 数据类型
### 	整数类型
​		bit
​		bool
​		tiny int
​		small int
​		medium int
​		int
​		big int
### 	浮点数类型
​		float
​		double
​		decimal
### 	字符串类型
​		char：固定长度，char(n)中n代表字符个数，并不代表字节个数,存储上限255,适合短、固定长度的字符串，对于非常短的列，char在存储空间上更有效率
​		varchar：可变长度，n代表字符个数，存储上限65535字节（行的长度上限）,需要额外的1或2个字节记录长度
​		tiny text
​		text：保存字符数据
​		medium text
​		longtext
​		tiny blob
​		blob：保存二进制数据
​		medium blob
​		long blob
### 	日期类型
​		date
​		date time
​		timestamp
​		time
​		year
#### 	其他类型
​		binary
​		var binary
​		enum
​		set
​		geometry
​		point
​		multipoint
​		...
## 索引
### 	需要创建索引
​		主键字段建立唯一索引
​		频繁作为查询条件的字段
​		查询中与其他表关联的字段，外键关系建立索引
​		查询中排序的字段
​		查询中统计或分组字段
### 	不要创建索引
​		表记录太少
​		经常增删改的表
​		数据重复且分布均匀的表字段（区分度不高，意义不大）
​		where条件用不到的字段
### 	innodb 
​		page默认大小16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
## 事务
### 	ACID-事务基本要素
​		A（atomicity）原子性:一个事务中的所有操作，要么全部完成，要么全部不完成
​		C（consistency）一致性:在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。
​		I(isolation)隔离性：一个事务的执行不能影响到其它事务的执行，并发执行的各个事务之间不能互相干扰。
​		D（durability）持久性：事务完成以后，该事务对数据库所做的更改便持久的保存在数据库中。
### 	并发事务处理的问题
​		更新丢失：事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题
​		脏读：事务A读取了事务B未提交的数据，然后事务B回滚,A读到的数据就是脏数据,
​		不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更改并提交，导致事务A多次读取同一数据时，结果不一致。
​		幻读：类似于不可重复读，不可重复读指的是同一数据多次读取不一致，幻读是指在一个范围内，多次读取的数据条数不一致.
### 	事务隔离级别
​		读未提交（read uncommitted）：最低的隔离级别，可能导致脏读、幻读、不可重复读
​		读已提交（read committed）：允许读取并发事务已经提交的数据，可以阻止脏读，可能发送幻读、不可重复读
​		可重复读（repeatable read）--默认事务隔离级别：可以阻止脏读和不可重复读，但幻读仍有可能发生。(innodb中通过mvcc避免的幻读)
​		可串行（serializable）：最高的隔离级别，所有事务依次逐个执行，虽然可以防止所有问题。但是基本上不用
### 	MVCC多版本并发控制(innodb)
​		committed read | repeatable read两种隔离级别下工作
####   实现
​	聚簇索引列中额外记录了两个必要的隐藏列：
​		trx_id：记录改动后最新的事务ID
​		roll_pointer:相当于指针，可以通过它在undo日志中找到上一个版本的数据
read view:包含当前系统中的活跃的读写事务的id列表,命名为m_ids
​			如果被访问版本的trx_id小于m_ids中的最小值，说明生成该版本的事务在生成read view的时候已经提交，改版本可访问
​			如果trx_id大于m_ids中的最大值，表明生成该版本的事务在生成read view后才生成，不可访问
​			如果trx_id在mids的最大值和最小值之间，则判断是否在mids列表中，存在说明创建read view的时候该版本的trx_id的还未提交，不可访问；如果不在，可访问。
​			read committed -- 每次读取数据都生成一个read view
​			repeatable read -- 只在第一次读取数据时生成一个read view
​		在Innodb的mvcc实现下，repeatable read的实现是可以解决幻读问题的。
### 	事务日志
#### 		redo log
​			实现持久性和原子性
​			事务中的操作，会都先写入存储引擎中的日志缓存中，事务提交前，日志需要提前刷到磁盘持久化。
​			系统启动时为redo log分配了一块连续的存储空间，写入log时是顺序IO，所有的事务共享redo log的存储空间.
​			通过redo log 把数据的改动由随机IO转变为顺序IO--日志持久化相当于事务持久化了
​			innodb后台有一个线程智能的刷新log中的变更，可以批量写入，使的数据写入更顺序，以提高效率。
​			本质上是更新数据从一次随机IO变更成两个顺序IO--第一次写日志，第二次写数据文件
#### 		undo log
​			实现一致性
​			主要为事务的回滚服务，记录了数据在每个操作前的状态.
#### 		其他日志
​			错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
​			查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
​			慢查询日志：设置一个阙值，将运行时间超过该值的所有sql语句都记录到 慢查询日志文件中，
​			二进制日志：记录对数据库执行更改的所有操作。
​			中继日志：二进制日志，用来给slave库恢复。
## 锁
​	读锁
​	写锁
​	表级锁:开销小，加锁快，粒度大，并发度低
​	行级锁：开销大，加锁快，粒度小，并发度高

### 	innodb的意向锁（IS、IX）
​		表级锁，不会和行级的读写锁冲突，只会和表级的读写锁冲突。
​		          S          X
​	    IS      兼容      互斥
​		IX      互斥      互斥
​		当向一个表添加表级锁时，如果没有意向锁，则需要遍历整个表判断是否有行锁的存在，以免发生冲突；有了意向锁，只需要判断意向锁与要添加的标所是否兼容即可。而无需遍历整个表。

### 	记录锁
​		锁的是索引记录,如果没有索引，innodb会创建隐式的索引,并锁这个隐式索引。行锁就是记录锁。
​		如果索引失效会导致行锁变表锁，比如字符串类型查询不加引号的情况,
### 	自增锁
​		特殊的表级锁，事务插入自增列的时候需要获取，当一个事务插入的时候，其他的事务都需要等待，这样第一个事务才能获得连续的自增值。
### 	间隙锁
​		索引记录之间的锁,只阻止其他事务插入间隙，不阻止其他事务获得间隙锁。可以解决幻读的问题。(r_c隔离级别下间隙锁是关闭的)
### 	死锁
#### 		innodb避免死锁
-			为了在单个innodb表上执行多个并发写入操作时避免死锁，可以在事务开始时使用select ... for update 获取必要的锁，其实这些行的改动是在之后执行的。
-			先获取共享锁，再获取排他锁的情况下，有可能其他的事务也已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁
#### 		myisam避免死锁
- 		在自动加锁的情况下，myisam总是一次获得sql语句所需要的全部锁。
## 调优
### 	索引优化
-    最左前缀原则
-	 	不在索引列上做如何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
-		is null ,is not null 也无法使用索引
-		字符串不加单引号索引失效
-		少用or，用它来连接时会索引失效
- <，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描
### 一般性建议
  -		对于单键索引，尽量选择针对当前query过滤性更好的索引
  -		在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
  -		在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
  -		尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的
  -		少用Hint强制索引
### 查询优化
 -		永远小标驱动大表（小的数据集驱动大的数据集）
 -		order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序
 -		group by实质是先排序后进行分组，遵照索引建的最佳左前缀；where高于having，能写在where限定的条件就不要去having限定了
### 分区、分表、分库（todo）
### 主从复制(todo)
## 其它
### 	百万级别或以上的数据如何删除
1.先删除索引（此时大概耗时三分多钟）
2.然后删除其中无用数据（此过程需要不到两分钟）
3.删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
4.与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。